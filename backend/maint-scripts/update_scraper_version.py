#!/usr/bin/env python3

"""
Script to update schedules and requested tasks with new image tags or offliner
definitions.

EXAMPLES:

1. Update image tag for all schedules and requested tasks using a specific offliner:
   ./update_scraper_version.py -o mwoffliner -t 2.1.0

2. Update recipe and requested tasks to a new offliner definition version:
   ./update_scraper_version.py -o mwoffliner -d 2.1.0

In cases where you want to add, remove, or rename fields in the recipe and requested
tasks flags, probably, to make the flags conform to the new offliner definition,
you can use the -n flag to add, remove, or rename fields. The names you specify
should be the same as the ones generated by the alias generator function of the
offliner, or the alias field in the offliner definition. This is because when the
config is dumped to the database, the flags are named according to the alias, not the
top level key that houses it's specification. For example, if the offliner definition
contains a new field like:

    "article_list_to_ignore": {
        "type": "string",
        "required": false,
        "title": "Article List to ignore",
        "description": "List of articles to ignore"
    }
Then, the name you provide to the -n flag should be "articleListToIgnore" if the base
model of the offliner is "CamelModel". Or "article-list-to-ignore" if the base model
of the offliner is "DashModel". Generally, if the new definition has new fields that
are nullable or removes fields, you can update without the -n flag because Pydantic
removes extra fields automatically when we call model_dump before saving to the
database. If you must use the -n flag, here are some examples:

3. Add a new field to recipe and requested tasks flags (using '+' as old name):
   ./update_scraper_version.py -o mwoffliner -d 2.1.0 -n "+:new_field"

4. Remove a field from recipe and requested tasks flags (using '-' as new name):
   ./update_scraper_version.py -o mwoffliner -d 2.1.0 -n "old_field:-"

5. Rename a field in recipe and requested tasks flags:
   ./update_scraper_version.py -o mwoffliner -d 2.1.0 -n "old_name:new_name"

6. Multiple name mappings (add, remove, and rename in one command):
   ./update_scraper_version.py -o mwoffliner -d 2.1.0 \
     -n "+:new_field,old_field:-,old_name:new_name"
"""

import argparse
from typing import cast

import sqlalchemy as sa
from sqlalchemy.orm import Session as OrmSession
from sqlalchemy.orm.attributes import flag_modified

from zimfarm_backend import logger
from zimfarm_backend.common.schemas.models import ScheduleConfigSchema
from zimfarm_backend.common.schemas.orms import OfflinerDefinitionSchema, OfflinerSchema
from zimfarm_backend.db import Session
from zimfarm_backend.db.models import RequestedTask, Schedule
from zimfarm_backend.db.offliner import get_offliner
from zimfarm_backend.db.offliner_definition import (
    create_offliner_instance,
    get_offliner_definition,
    get_offliner_definition_by_id,
    update_offliner_flags,
)
from zimfarm_backend.db.requested_task import create_requested_task_full_schema
from zimfarm_backend.db.schedule import create_schedule_full_schema, update_schedule


def parse_name_mappings(value: str) -> dict[str, str]:
    """Parse name mappings from string format 'oldName:newName,oldName:newName...'"""
    if not value:
        return {}

    mappings: dict[str, str] = {}
    for mapping in value.split(","):
        if ":" not in mapping:
            raise argparse.ArgumentTypeError(
                f"Invalid mapping format: '{mapping}'. Expected 'oldName:newName'"
            )

        old_name, new_name = mapping.split(":", 1)
        if not old_name.strip() or not new_name.strip():
            raise argparse.ArgumentTypeError(f"Empty name in mapping: '{mapping}'")

        mappings[old_name.strip()] = new_name.strip()

    return mappings


def update_schedules(
    session: OrmSession,
    *,
    offliner: OfflinerSchema,
    offliner_definition: OfflinerDefinitionSchema | None,
    image_tag: str | None,
    name_mappings: dict[str, str],
) -> int:
    nb_modified: int = 0

    for obj in session.execute(
        sa.select(Schedule).where(
            Schedule.config["offliner"]["offliner_id"].astext == offliner.id
        )
    ).scalars():
        schedule = create_schedule_full_schema(obj, offliner)
        schedule_config = cast(ScheduleConfigSchema, schedule.config)

        if offliner_definition is None:
            offliner_definition = get_offliner_definition_by_id(
                session, schedule.offliner_definition_id
            )

        if image_tag:
            logger.info(
                f"setting {offliner.id} image tag for schedule {obj.name} "
                f"to {args.image_tag}..."
            )
            schedule_config = schedule_config.model_copy(
                update={"image": {"name": schedule_config.image.name, "tag": image_tag}}
            )

        if offliner_definition.id != schedule.offliner_definition_id:
            logger.info(f"setting offliner definition for schedule {obj.name}...")

        data = update_offliner_flags(
            offliner=offliner,
            offliner_definition=offliner_definition,
            data=obj.config["offliner"],
            name_mappings=name_mappings,
        )

        schedule_config = ScheduleConfigSchema.model_validate(
            # reuse the existing config except for the offliner and image
            {
                **schedule_config.model_dump(
                    mode="json",
                    exclude={"offliner"},
                    context={"show_secrets": True},
                ),
                "offliner": create_offliner_instance(
                    offliner=offliner,
                    offliner_definition=offliner_definition,
                    data=data,
                    skip_validation=True,
                    extra="allow",
                ),
            },
            context={"skip_validation": True},
        )

        update_schedule(
            session,
            offliner_definition=offliner_definition,
            author="maint-scripts",
            schedule_name=schedule.name,
            new_schedule_config=schedule_config,
            comment="updates made via update_scraper_version",
        )

        nb_modified += 1
    return nb_modified


def update_requested_tasks(
    session: OrmSession,
    *,
    offliner: OfflinerSchema,
    offliner_definition: OfflinerDefinitionSchema | None,
    image_tag: str | None,
    name_mappings: dict[str, str],
) -> int:
    nb_modified: int = 0

    for obj in session.execute(
        sa.select(RequestedTask).where(
            RequestedTask.config["offliner"]["offliner_id"].astext == offliner.id
        )
    ).scalars():
        if image_tag:
            logger.info(
                f"setting {offliner.id} image tag for requested task {obj.id} "
                f"to {args.image_tag}..."
            )
            obj.config["image"]["tag"] = image_tag
            flag_modified(obj, "config")

        if offliner_definition:
            logger.info(f"setting offliner definition for requested task {obj.id}...")
            if name_mappings:
                obj.config["offliner"] = update_offliner_flags(
                    offliner=offliner,
                    offliner_definition=offliner_definition,
                    data=obj.config["offliner"],
                    name_mappings=name_mappings,
                )
            obj.offliner_definition_id = offliner_definition.id
            flag_modified(obj, "config")
        # Just needed to ensure our model still works
        create_requested_task_full_schema(session, obj)
        nb_modified += 1
    return nb_modified


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Update schedules and requested tasks image tag "
        "or offliner definition",
    )

    # Required offliner specification
    parser.add_argument(
        "-o", "--offliner", required=True, help="Specify which offliner to update"
    )

    parser.add_argument(
        "-t", "--image-tag", help="Image tag to update to", metavar="TAG"
    )
    parser.add_argument(
        "-d",
        "--offliner-definition-version",
        metavar="VERSION",
        help="Offliner definition version to update",
    )

    parser.add_argument(
        "-n",
        "--name-mappings",
        metavar="MAPPINGS",
        help="Name mappings in format 'oldName:newName,oldName:newName...'. "
        "When 'oldName' is '+', 'newName' would be added to the recipe flags. "
        "When 'newName' is '-', 'oldName' is removed from the recipe flags. "
        "When 'newName' and 'oldName' are different, data at 'oldName' is renmaed "
        "with 'oldName' as key.",
        type=parse_name_mappings,
        default={},
    )
    args = parser.parse_args()

    with Session.begin() as session:
        offliner = get_offliner(session, args.offliner)

        if args.offliner_definition_version:
            offliner_definition = get_offliner_definition(
                session, args.offliner, args.offliner_definition_version
            )
        else:
            offliner_definition = None

        nb_schedules_modified = update_schedules(
            session,
            offliner=offliner,
            offliner_definition=offliner_definition,
            image_tag=args.image_tag,
            name_mappings=args.name_mappings,
        )
        logger.info(f"updated {nb_schedules_modified} schedule(s) ")

        nb_requested_tasks_modified = update_requested_tasks(
            session,
            offliner=offliner,
            offliner_definition=offliner_definition,
            image_tag=args.image_tag,
            name_mappings=args.name_mappings,
        )
        logger.info(f"updated {nb_requested_tasks_modified} requested tasks ")

    logger.info("FINISH!")
